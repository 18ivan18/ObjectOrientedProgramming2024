## Потоци и Файлове (част 1). Текстови файлове.

Видове потоци:

- Потоци за вход (istream).
- Потоци за изход (ostream).

![enter image description here](https://i.ibb.co/VDdDSnM/potoci.gif)

##### Пример за работа с вход от конзолата. cin (обект от тип istream).

```c++
#include <iostream>

int main()
{
	int a, b;
	std::cin >> a >> b;
}
```

Четем от стандартния вход.

##### Пример за работа с поток за изход. cout (обект от тип ostream).

```c++
#include <iostream>

int main()
{
	int a = 10;
	int b = 12;
	int c = a + b;

	std::cout << a << " + " << b << " = " << c << std::endl;
}
```

### Работа с поток за вход от файл (ifstream)

Пример за четене от файл!

```c++
#include <iostream>
#include <fstream>

int main()
{
	std::ifstream file("myFile.txt");

	if (!file.is_open())
	{
		std::cout << "Error!" << std::endl;
		return -1;
	}
	int a, b;

	file >> a >> b;

	file.close();
}
```

Пример за прочитане на цялото съдържание файл:

```c++
#include <iostream>
#include <fstream>

const int BUFF_SIZE = 1024;
int main()
{
	std::ifstream file("myFile.txt");

	if (!file.is_open())
	{
		std::cout << "Error!" << std::endl;
		return -1;
	}

	while (!file.eof())
	{
		char buff[BUFF_SIZE];
		file.getline(buff, BUFF_SIZE);

		//do something with the line
		std::cout << buff << std::endl;
	}
	file.close();
}
```

### Работа с поток за изход към файл (ofstream)

```c++
#include <iostream>
#include <fstream>


int main()
{
	std::ofstream file("myFile.txt");

	if (!file.is_open())
	{
		std::cout << "Error!" << std::endl;
		return -1;
	}
	int a = 3;
	int b = 10;

	file << a << " " << b << " " << a + b << std:::endl;

	if(!file.eof()) //check if the file has ended
		std::cout << "The file contains more data after the two integers!" << std::endl;

	file.close();
}
```

- ifstream или istream - get указател, който реферира елемента, който ще се прочете при следващата входна операция.

- ofstream или ostream - put указател, който реферира мястото, където ще се запише следващият елемент.

### Режими на работа

```c++
	ifstream str("file.txt", <режим на работа>).
```

Режимът на работа е цяло число.

| ios         | Ефект:                                                                                                                           |     |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------- | --- |
| ios::in     | Отваря файл за извличане.                                                                                                        | 1   |
| ios::out    | Отваряне на файл за вмъкване. Допуска се вмъкване на произволни места във файла. Ако файлът съществува, съдържанието се изтрива. | 2   |
| ios::ate    | Отваря за вмъкване и установява указателя put в края на файла. Допуска вмъкване на произволни места.                             | 4   |
| ios::app    | Отваря за вмъкване и установява указателя put в края на файла                                                                    | 8   |
| ios::trunc  | Ако файлът съществува, съдържанието се изтрива.                                                                                  | 16  |
| ios::binary | Превключва режима от текстов в двоичен                                                                                           | 32  |

```c++
	ofstream file("file.txt", ios::out | ios::app).
```

## Задачи

**Задача 1**: Напишете програма, която отпечатва собствения си код.

**Задача 2**: Напишете функция, която приема име на съществуващ файл и име и копира съдържанието на същестуващия файл в нов файл.

**Задача 3**: Напишете програма, която чете comma-separated values (**CSV**) файл със студенти **със следните 4 полета**: Първо име, Фамилно име, Стринг на факултетен номер, Имейл

1.  Със стартирането на програмата потребителят да въвежда име на файл, който да бъде зареден в паметта.
2.  Напишете функция, която след зареждане на файла да отпечатва на **стандартния изход** информация за студента при подаден **факултетен номер**.
3.  Напишете функция, която **по подаден факултетен номер, специалност и низ**, променя email-a на студента, който има дадения факултетен номер и учи подадената специалност, с подадения низ.
4.  Напишете функцията, която приема низ (име на файл) и запазва студентите в същия формат (**CSV**). Т.е. при повторно пускане на програмата да може да прочете новия генериран файл. Нека файлът се запазва при затваряне на програмата автоматично.

! Студентите имат уникални факултетни номера, в рамките на една специалност !

Да се реализира прост интерфейс, с който да се извикват написаните фунцкии през конзолата:

**Пример** (входът от потребителя започва с '>'):

```
Open file:
>students.csv
File successfully opened!
>print 123 ComputerScience
Name = Stefan Velkov, Major: Computer science, Email: stefan@yahoo.com, FN: 123
>edit 123 ComputerScience stefcho@abv.bg
>print 123 ComputerScience
Name = Stefan Velkov, Email: stefcho@abv.bg, FN: 123
>save students2.csv
file students2.csv successfully saved!
```

# Двоични файлове.

## Режими за работа с файлове

| Режим:         | Ефект:                                                                                                |
| -------------- | ----------------------------------------------------------------------------------------------------- |
| ios::in        | Отваря файл за четене (по подразбиране на ifstream)                                                   |
| ios::out       | Отваря файл за четене (по подразбиране на ofstream)                                                   |
| ios::binary    | Отваря файл в двоичен режим                                                                           |
| ios::trunc     | Ако файлът съществува, съдържанието му се изтрива след отваряне на поток                              |
| ios::app       | Отваря файлът за вмъкване. Поставя put указателят в края. Не се допуска вмъкване преди края на потока |
| ios::ate       | Отваря файлът за вмъкване. Поставя put указателят в края. Допуска вмъкване на прозиволни места        |
| ios::nocreate  | Отваря за вмъкване, само ако файлът с указаното име съществува.                                       |
| ios::noreplace | Отваря за вмъкване само ако файлът с указаното име не съществува.                                     |

### Пример:

```c++
#include <iostream>
#include <fstream>

int main()
{
	std::ofstream f("test.txt", ios::app);

	if (!f.is_open())
	{
		std::cout << "Error while opening file!" << std::endl;
		return -1;
	}
	f << 33; //appends at the end of the file

	f.close();
}
```

## Флагове на състоянията на потока

| Флаг:   | Значение:                                                                   |
| ------- | --------------------------------------------------------------------------- |
| bad()   | Има загуба на информация. Някоя операция за четене и писане не е изпълнена. |
| fail()  | Последната входно/изходна операция е невалидна.                             |
| eof()   | Достигнат е края на файла.                                                  |
| good()  | Всички операции са изпълнени успешно.                                       |
| clear() | Изчиства състоянието на потока (Вече good() ще върне истина).               |

## Двоични файлове.

Изпоилзваме функциите:

1. .read(char\* memoryBlock, size_t size);
2. .write(const char\* memoryBlock, size_t size);

Обърнете внимание, че функцията приема **char\***. Ако искаме да запазим променлива от друг вид, ще трябва експлицитно да преобразуваме указателя към тип char\* (без значение, че указателят не сочи към елементи от тип char)

### Пример за писане в двоичен файл:

```c++
#include <iostream>
#include <fstream>

int main()
{
	std::ofstream f("file.dat");

	int a = 155555;

	f.write((const char*)&a, sizeof(int));
}
```

### Пример за четене от двоичен файл:

```c++
#include <iostream>
#include <fstream>

int main()
{
	std::ifstream f("file.dat");

	int a;

	f.read((char*)&a, sizeof(int));

	std::cout << a << std::endl;
}
```

### Съдържанието на двоичния файл:

![enter image description here](https://i.ibb.co/G3R72qG/sudurjanie.png "Binary file example")

Байтовете се записват в **обратна посока**. Най-старшият байт е последен. Следователно запаментеното число е **00025fa3**, което е точно шестанйсетичния запис на числото **155555**.

### Примери за запазване на стуктури във файл.

- запазване на структура,която не използва динамична памет - **simple_struct_binary.cpp** и **student_staticName_to_binary.cpp**
- запазване на структура,която използва динамична памет - **students_dynamicName_to_binary.cpp**

### Пример за запазване на масив от стуктури във файл.

- запазване и четене на масив от обекти,които не използва динамична памет - **array_of_students_write.cpp**, **array_of_students_read.cpp**

```c++
#include <iostream>
#include <fstream>

struct Test
{
  char ch;
  int a;
};

int main()
{
    std::ofstream f("output.dat", ios::binary);

    if(!f.is_open())
    {
        std::cout << "Error!" << std::endl;
        return -1;
    }

    Test arr[3] = {{'a', 400},{'b', 500},{'c', 600}};

    f.write((const char*)&arr, sizeof(arr));

    f.close();
}

```

След изпълнението на програмата, файлът (**output.dat**) изглежда така:

![Image of the binary file after running the code](https://i.ibb.co/0JthLd6/3-A978-D14-7-C7-A-4-ABD-8-B0-C-DA27-F6-E9-CD0-A.png "Binary file")

## Позициониране във файл

- tellg() - Връща позицития на текущия символ в **потока за четене**
- tellp() - Връща позицития на текущия символ в **потока за писане**
- seekg(offset, direction) - Премества get-указателят на позцития на **потока за четене**.
- seekg(streampos idx) - Премества get-указателят на позция idx на **потока за четене**.
- seekp(offset, direction) - Премества put-указателят на позцития на **потока за писане**.
- seekp(streampos idx) - Премества put-указателят на позция idx на **потока за писане**.

-**offset** : целочислена стойност. Отместването от direction.

-**direction** : Може да заема следите стойностти:

1. ios::beg - началото на файла.
2. ios::cur - текущата позиция във файла.
3. ios::end - края на файла.

## Задачи

**Задача 1:** Да се напишат програми, които запазват/четат масиви от обекти, които не използват динамична памет.

**Задача 2:** Да се напише функция, която намира големината на файл.

**Задача 3:** Да се напише функция, която заменя всяко срещане на символ във файл с друг символ. Съдържанието на файла не трябва да се зарежда в паметта.

**Задача 4**:

Да се реализира програма за изглед и модификация на двоични файлове (hex viewer). При стартиране на програмата трябва да се въведе път до двоичен файл и да зареди съдържанието на файла в паметта. След като файлът се е заредил в паметта, трябва да поддържате следните операции:

- Преглед на файла (view) отпечатва байтовете на файла (в шестнайсетична бройна система). След това да се отпечатат интерпретацията на байтовете като символи. Ако байтът отговаря на малка/голяма латинска буква, то да се отпечата символа. В противен случай да се отпечатва точка.
- Промяна на байт по индекс (change).
- Премахване на последния байт (remove)
- Добавяне на байт в края (add ).
- Запазване на промените в същия файл (save)
- Запазване на промените в друг файл (save as )

Нека имаме двоичен файл, myData.dat, който се е получил след изпълнението на следния c++ код:

```c++
int x = 25409;
ofstream file(“myData.dat”, ios::binary);
file.write( (const char*)&x, sizeof(x));
```

Да се реализира прост интерфейс, с който да се извикват написаните фунцкии през конзолата.

**Важно** Не се ползволява използването на stl, както и std::hex.

**Пример** (входът от потребителя започва с '>'):

```
Enter a file path:
> myData.dat
File loaded successfully! Size: 4 bytes
> view
41 63 00 00
A  c  .  .
> change 1 65
Operation successfully executed!
> view
41 65 00 00
A  e  .  .
> remove
> view
41 65 00
A  e   .
> save
File successfully saved
```

**Забележка:** Не се изисква поддържането на конзолен интерфейс. Можете само да реализирате функциите и да ги изпробвате в main функцията.

**Задача 5**:
За да елиминира ръчното броене на бюлетини и неработещите машини за гласуване, държавата е поръчала на вас да направите софтуер, който да брои и сумира автоматично гласовете на всяка партия от всички секции в страната и чужбина.

(За целите на задачата, приемаме, че в страната има само три партии с имената PARTY1, PARTY2, PARTY3.)

Новите машини за гласуване ще съхраняват бройките получени гласове в текстов файл със следния формат:

{SECTION1_PARTY1_VOTES} {SECTION1_PARTY2_VOTES} {SECTION1_PARTY3_VOTES}
{SECTION2_PARTY1_VOTES} {SECTION2_PARTY2_VOTES} {SECTION2_PARTY3_VOTES}
{SECTION3_PARTY1_VOTES} {SECTION3_PARTY2_VOTES} {SECTION3_PARTY3_VOTES}
{SECTION4_PARTY1_VOTES} {SECTION4_PARTY2_VOTES} {SECTION4_PARTY3_VOTES}
...

т.е. един ред пази гласовете, получени в една изборна секция, като на всеки ред с един интервал са отделени цели числа, представляващи бройката гласове за съответната партия в тази секция (по 3 цели числа на ред, понеже имаме 3 партии).

От вас се изисква да създадете два класа - `SectionVotes` и `ElectionResultsDatabase`.

## SectionVotes

Класът трябва да пази информация за подадените гласове за всяка от партиите в една изборна секция.

За да може тази информация да бъде лесно прочетена или записана във файл с формат като горепосочения, трябва да бъдат предефинирани операторите `<<` и `>>` за работа със съответните потоци.

## ElectionResultsDatabase

Класът трябва да борави с файлове с формат като горепосочения и да пази информация за всички постъпили гласове във всички секции. Има следните методи:

- void addResultsFromFile(const char\* filename): Прочита информация, съдържаща се във файл с име `filename` и с формат като горепосочения.
  - Не трябва да се трие вече съществуващата информация в класа, а само да се добавя към нея
  - Съдържанието на файла не трябва да бъде променяно по никакъв начин
  - Очаквайте файловете да бъдат само с коректно форматирани данни
- int votesForParty(Party) const: Връща колко гласове общо е събрала дадената партия
- Party winningParty() const: Връща партията с най-много гласове от изборите.
  - Ако PartyX и PartyY (X < Y) имат еднакъв брой гласове, то в този случай се очаква да върне PartyX
- int numberOfSections() const: Връща от колко изборни секции има информация за гласуването

За лесната работа с този тип файлове, чийто формат е посочен по-горе в условието, трябва и да се предифинират операторите `<<` и `>>` за работа със съответните потоци:

- Операторът за четене от поток не трябва да изтрива съществуващите данни в класа, а само добавя прочетените такива от целия поток.
- Операторът за писане в поток трябва да копира в потока абсолютно всички данни, пазещи се в класа, във формат като горепосочения.
