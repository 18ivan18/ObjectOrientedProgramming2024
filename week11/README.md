# Подготовка за контролно

# Задача 1 
## От контролно 2021
При решаването на задачата можете да използвате наготово:

- std::string и
- std::vector

Работата с паметта е ваша отговорност. За класовете реализирайте всички необходими компоненти, за да гарантирате коректната работа на вашата програма във всички тестови сценарии. В контролното ще се оценява архитектурното решение, което сте реализирали.

## Реализирайте клас Vehicle (превозно средство). То трябва да има следните член-данни:
- regnum - регистрационен номер, константа от тип низ.
За класа да се реализират подходящи конструктори.

## Програмата трябва да работи със следните превозни средства - леки коли (car) и камиони (truck).
 Леките коли имат брой пътници, които могат да превозват и булева стойност, която показва дали водачът е възпитан. Камионите имат поле за товароносимост (load capacity). Колите и камионите заемат определено пространство, когато бъдат паркирани и за него се плаща определена цена. Цената, която се заплаща за паркиране на съответното превозно средство се пресмята по следния начин:

- Цената за паркиране на камион е равна на товароносимостта му разделена на 100. 
- Ако шофьорът на колата е възпитан, той може да се възползва от специална префериaнциална цена - 1 лев. Ако това не е така, цената е
между 2 и 10 лева. Точната стойност се определя на случаен принцип при паркирането (използвайте функцията rand())

## Реализирайте клас Garage (гараж). 
Класът трябва да представя реален гараж, в който може да се паркират различни коли и камиони. За класа да се реализират подходящи конструктори и методи за добавяне на ново превозно средство към него. Гаражът трябва да може да побира колкото е нужно на брой коли.

## Да се реализира клас Minibus (микробус). 
Класът представя специално хибридно превозно средство, което прилича на лек автомобил, притежава същите характеристики, но може да превозва и товари. Микробусът има и допълнителна характеристика - брой на вратите. Да се реализират подходящи конструктори за класа.

## Микробусът може да паркира срещу сума, която се изчислява като средно-аритметичното на сумата, за която би паркирал камион със същите характеристики (товароносимост) и сумата за лека кола с тази характеристика за шофьора.

## Реализирайте главна функция, която създава гараж и множество от камиони, коли и микробуси, които да бъдат паркирани в него. Да се реализира функция, която намира общата сума, която притежателят на гаражът ще получи от паркираните в него автомобили.

**Бонус:** Реализирайте Unіt Tests за създадените методи и класове. doctest.h

# Задача 2
 Имате 3 вида превозни средства - автомобил, миниван и камион. Всеки от тях има предварително зададени марка (символен низ) и
максимална скорост (цяло число).
- Максималната скорост на автомобила е м/у 180 и 240 км/ч.
- Максималната скорост на миниван е м/у 120 и 160 км/ч.
- Максималната скорост на камиона е м/у 80 и 140 км/ч

Всяко превозно средство може да се придвижва по 3 вида път: третокласен, скоростен и магистрала.
- Автомобилът, като маневрено превозно средство, се движи със своята максимална скорост, независимо от пътя.
- Миниванът се движи с максимална скорост на магистралата, но по скоростният път се движи 2-пъти по-бавно, а на третокласния път се
движи 3 пъти по-бавно (от макс. си скорост).
- Камионът се движи на магистралата 2-пъти по бавно от макс. си скорост, на скоростен път 4 - пъти по-бавно, а на третокласен път - с
10км. в час.

Да се реализира клас гараж, в който има колекция от превозни средства. Всеки гараж има максимален капацитет. Трябва да може да добавяме
произволно превозно средство.
- Да се реализира функция, която приема дължина на път (дължината на магистрален път, скоростен път и третокласен път по трасето) и
време, за което трябва да го изминем и ни връща като резултат колко от нашите превозни средства могат да изпълнят поръчката.

# Задача 3. Да се реализира клас Bag, който представлява торба с елементи от произволен тип. 
Нашата торба е магическа и в нея винаги има място за още елементи. В торбата можем да добавяме елемент само на отгоре и да махаме само този, който е на върха на торбата. Всяка торба трябва да
притежава уникален идентификатор, който започва от 0 и се увеличава с 1.
Реализирайте :
- Функция Add, която добавя елемент в торбата.
- Функция Get, която връща като резултат елемента на върха и го премахва от торбата.
- Оператор +, който събира 2 торби в 1 нова торба. Първо трябва да седят елементите на първата торба, в същия ред, в който са били. Върху
тях трябва да седят елементите на другата торба в обратен ред.
- Оператор ==, който връща истина, тогава и само тогава, когато 2-те торби имат еднакви елементи на еднакви позиции.
Да се реализира клас ImprovedBag, която има същите методи/оператори като Bag, но притежава и:
- Символен низ с произволна дължина, който представлява име на производителя.
- Функция Insert, която приема елемент x и цяло число i. Методът вмъква елемента x на позиция i (или на най-близката възможна). Всички
елементи от индекс i до края, трябва да бъдат преместени с една позиция напред, за да се освободи място за новия елемент.
# Задача 4
В програмите, които един софтуерен разработчик създава, често се налага да
се наблюдава настъпването на различни събития или промяната на някакви
стойности.

Като прост пример може да си представим един сензор, който измерва и
излъчва различни стойности през интервали от време. Кой обаче наблюдава
тези стойности? На теория може неограничен брой "наблюдатели" да се
"закачат" към сензора с цел получаване на всяка нова измерена стойност.
Могат да съществуват обаче различни начини както за наблюдаване, така и за
изпращане на стойности. В тази задача ще направим няколко такива, с
помощта на предоставените хедъри и условията към тях, описани долу.

## Данните

**Message**

Класът с данни се казва `Message` (съобщение) и съдържа конструктор с
параметър от тип `int`, който запазва стойността му в публично поле от същия
тип с името `data`. Стойността на това поле, веднъж инициализирана, не трябва
да може да бъде променяна.

**Класове, които излъчват данни (Publishers)**

**SimplePublisher**

- методът `subscribe` позволява закачането на още един конкретен
наблюдател към инстанцията
- методът `unsubscribe` позволява разкачането на конкретен наблюдател от
инстанцията
- методът `signal` изпраща параметъра от тип `Message` на всички
наблюдатели, закачени към инстанцията, чрез извикване на техния метод
signal

**BacklogPublisher**
- методът `subscribe` позволява закачането на още един конкретен
наблюдател към инстанцията, както и веднага му изпраща абсолютно
всички предишни ("пропуснати") съобщения чрез `signal` (в реда, в който
са били получени)
- методът `unsubscribe` позволява разкачането на конкретен наблюдател от
инстанцията
- методът `signal` изпраща параметъра от тип `Message` на всички
наблюдатели, закачени към инстанцията, чрез извикване на техния метод
signal

Hint 1: Думата "конкретен" не е случайна и подсказва нещо, което ще ви
улесни в имплементацията на методите - Този обект не трябва да е силно
обвързан с класа Publisher.

**Класове, които наблюдават данни (Subscribers)**

Всеки един от тях трябва да съдържа публично поле с име `id` от тип `std::string`
с цел идентификация (два наблюдетеля с едно и също id да се смятат за
равни). Стойността на полето, веднъж инициализирана, не трябва да може да
бъде променяна.

Получаването на съобщения става чрез `signal`, а четенето им след това - чрез
`read`. Разликата между трите класа се проявява при четенето и обработването
на получените данни.
При никакви получени данни и трите класа връщат 0 при четене.

**Averager**
- При четене връща средната стойност на всички данни, получени досега.

**MovingAverager**
- Съдържа публично поле с име `windowSize` от тип size_t .Стойността на
това поле, веднъж инициализирана, не трябва да може да бъде
променяна.
- При четене връща средната стойност само на последните `windowSize` на
брой съобщения.

**PeriodicSampler**
- Приема в конструктор `period` от тип `size_t`
- При четене връща стойността на последното получено неигнорирано
съобщение. За игнорирано съобщение смятаме всяко n -то съобщение
след първото получено, за което `n % period != 0`

**Пример:**
```
Averager* avg = new Averager("id1");MovingAverager* movAvg = new MovingAverager("id2", 5);
PeriodicSampler* perSam = new PeriodicSampler("id3", 3);
​
SimplePublisher pub;
pub.subscribe(avg);
pub.subscribe(movAvg);
pub.subscribe(perSam);
​
pub.signal(1);
pub.signal(2);
pub.signal(3);
pub.signal(4);
pub.signal(5);
pub.signal(6);
pub.signal(7);
pub.signal(8);
pub.signal(9);
​
avg.read(); // трябва да връща 5 (ср. аритм. на 1...9)
movAvg.read(); // трябва да връща 7 (ср. аритм. на 5...9)
perSam.read(); // трябва да връща 7 (стойността на шестото съобщение след първото; игнорира стойности 8 и 9)
```
**Клас, който управлява наблюдатели**

Клас `Repository` служи като хранилище за различни наблюдатели, независимо
от това от къде те получават своите данни. Поддържа операциите добавяне (създаване) на нов наблюдател и достъп до
наблюдател чрез неговото `id` .
Примери за употребата му разгледайте в приложения main.cpp файл.

Hint 2: Тук думата "конкретен" нарочно липсва.

Hint 3: Позволено е решаването на задачата по такъв начин, че вместо
``static_cast`` да е необходимо използването на ``dynamic_cast`` в приложените
примери.

Hint 4: Във всички хедъри има коментари с уточнения и подсказки,
разгледайте ги внимателно в случай, че нещо не ви е ясно.

Hint 5: Позволено е (и винаги е било) да променяте всеки един ред, който сме
ви дали в хедър файловете. За да компилира решението с тестовете е
необходимо просто да не се създават т.нар. "breaking changes", т.е. да не се
променят имената на дадените функции, полета и класове и т.н.

Hint 6: Ако не ви харесва употребата на void* нямате проблеми да
използвате нещо друго - той просто служи като пойнтър, който може да
бъде кастнат към всичко на теория.

# Задача 5

Един от най-използваните елементи от ООП-то, са т.нар. интерфейси и
абстрактни класове.

В езика C++ те не същестуват в същия вид, както например в езиците C#/Java,
целта на тази задача е да се създадат такива подобни.

**Comparable**

Ще играе ролята на интерфейс, чрез който ще показваме, че даден клас може
да се сравнява.
- Предефинирайте операторите == и != като абстрактни функции,
приемащи указател от тип Comparable

**Debug**

Ще играе ролята на интерфейс, чрез който ще даваме възможността, да
принтираме допълнителна информация за
състоянието на даден клас, с цел откриване на грешки.
- Създайте абстрактна функция `debug_print` , която да връща `string` обект.

**Serializable**
Ще играе ролята на интерфейс, показващ че даден клас може да се
`сериализира` (да се превърне до низ), както и
`десериализира` (че може да се създаде обект, по подаден низ).
- Създайте абстрактна функция `toString` , която връща string обект.
- Създайте абстрактна функция `fromString` , която приема `string` обект, и
модифицира текущия обект, спрямо подадения низ.

Пример:

Ако имаме дадения клас Foo:
```c++
class Foo {
public:
    int value;
};
```
`toString` може да връща стойността на value, а `fromString` ще приема един
такъв низ, и ще променя
стойността на value спрямо съдържанието на низа.

**Бележка:** За тези класове са предоставени header файлове, които съдържат
празен клас
Всеки един от тези класове, ще бъдат наследени от един специален клас Object

**Object**

Този абстрактен клас ще играе ролята на база, върху която ще стъпят всички
други класове в задачата.
За целите на конкретната задача, той ще съдържа и някои член-данни.
- Наследява Comparable, Debug и Serializable
- Конструктор с параметри
- Метод ``clone``, който прави дълбоко копие на текущия обект. Връща се `Object*`
- Име на файл (name)
- Локация на файл (location)
- Разширение на файл (extension)
- Метод за създаване на пълен път на файла
  - Формат: <location>/<name>.<extension>

**Бележка:** За този клас е предоставен непълен header файл, който трябва да
се допълни/разшири
С помощта на Object ще създадем още два класа - **Document** и
**KeyValueDatabase**

**Document**

Играе ролята на текстов документ, където можем да пишем и четем ред по ред
- Наследява Object
- Пази в себе си колекция от низове (един низ е равен на един ред)
- Метод за писане във документа `writeLine`
- Методи за четене в документа. Документа се чете ред по ред, като се
"помни" до къде сме прочели документа
  - Метод readLine , който връща следващия ред, който трябва да се
"прочете"
  - Метод readLine , приемащ аргумент кой ред да се прочете. След
извикването на този метод, четенето на документа продължава от
подадения ред
  - Ако не може да се прочете ред (например сме прочели документа
до край), да се хвърля std::out_of_range изключение
  - Броенето на редовете започва от 1
- Два документа са равни, когато техните редове са едни и същи (бележка:
ако редовете на документ 1 е подмножество на редовете на документ
2, документ 1 НЕ Е равен на документ 2)
- Сериализирането на един документ се извършва по следния начин:
  - На първите три реда се записва името, локацията и разширението
на документа
  - На следващите реда, се записва съдържанието на документа
  - След последния ред от документа, при сериализиране се очаква
да има нов ред също
- Десериализирането на един документ се извърша по същия начин- Принтирането на допълнителната информация се извършва по следния
начин:
  - За всеки ред от съдържанието, се записва нов ред Line
<номер_на_реда>:<ред>
  - След последния ред се очаква да има нов ред

Примерно извикване:
```c++
Document temp("temp", "/tmp", "doc");
​
temp.writeLine("This is an example doc");
temp.writeLine("This is another example line");
temp.writeLine("This is a third example line");
temp.writeLine("This is a forth example line");
​
std::cout << temp.readLine() << std::endl; //This is an example doc
std::cout << temp.readLine() << std::endl; //This is another example line
​
std::cout << temp.readLine(3) << std::endl; //This is a third example line
std::cout << temp.readLine() << std::endl; //This is a forth example line
​
std::cout << temp.readLine(1) << std::endl; //This is an example doc
std::cout << temp.readLine() << std::endl; //This is another example line
```

**Бележка:** За този клас е предоставен непълен header файл, който трябва да
се допълни/разшири

**KeyValueDatabase**

Играе ролята на база от данни, пазеща в себе си двойки от ключ и стойност.
- Наследява Object
- Пази в себе си двойки ключ и стойност, където ключът е низ, а
стойността - цяло число.
Съдържа метод за добавяне на нова двойка ключ и стойност. Ако ключът вече
се съдържа в колекцията,
- се хвърля std::invalid_argument
Съдържа метод за взимане на стойност, по подаден ключ. Ако ключът не се
съдържа в колекцията,
- се хвърля std::invalid_argument
- Две бази са равни, когато техните двойки от ключове и стойности са
равни (бележка: ако двойките ключ/стойност на база1 са
подмножество на тези от база2, база 1 НЕ Е равна на база 2)
- Сериализирането на една база се извършва по следния начин:
  - На първите три реда се записва името, локацията и разширението
на документа
  - На следващите редове, се записва ред със следния формат
<ключ>:<стойност>
  - Очаква се низа да завършва с нов ред
- Десериализирането на една база се случва по същия начин
- Принтирането на допълнителната информация се извършва по следния
начин:
  - За всяка двойка, се записва нов ред {<ключ>:<стойност>}
  - Очаква се низа да завършва с нов ред
За този клас е забранено използването на std::map , std::unordered_map и
всички други колекции,
- които предоставят търсена функционалност "наготово" ( std::vector
и други подобни са позволени)
Бележка: За този клас е предоставен непълен header файл, който трябва да
се допълни/разшири