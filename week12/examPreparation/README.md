# Задача 1
## Да се реализира нов език за обмен на данни - `FJSON` (fake json), който представлява колекция от различни двойки (pairs).

Всяка двойка се състои от наименование (key) и стойност (value).

Всяко наименование трябва да бъде низ с произволна дължина.

Различават се четири типа двойки в зависимост от типа на стойността:
Съответно могат да се се образуват различават 4 различни типа двойки:

- Със стойност низ (`StringPair`) - низът е с произволна дължина


Пример:
ключ: stringId

стойност: Hello World

- Със стойност дата (DatePair)

Пример:

ключ: First uni day

стойност: дата, състояща се от ден месец и година

- Със стойност време (TimePair)

Пример:

ключ: Work day start

стойност: време, състоящо се от час и минути(часът е от 0 до 23 часа)

- Със стойност дата и време (DateTimePair)

Пример:

ключ: OOP Exam

стойност: дата и време, състои се от ден, месец, година, час и минути


## Представянето на стойността трябва да е оптимално за съответния тип двойка.

Коректността на входа за датата и времето НЕ е гарантирана. При валидацията за датата може да приемете, че дните във всички месеци са 31. При подадени невалидни стойности, същите се заменят с валидна стойност по подразбиране - 31 за ден, 12 за месец, 00:00 за време и се извежда подходящо съобщение.


Да се реализира член-функция `toString`, която да връща `FJSON` под формата на низ.
Всяка двойка трябва да бъде форматирана в изходния низ по следния начин:

- Със стойност низ (StringPair) - {stringId : “Hello world”}
- Със стойност дата (DatePair) - {First uni day : 15.10.2021}
- Със стойност време (TimePair) -  {Work day start, 10:15
- Със стойност дата и време (DateTimePair) - {OOP Exam: 23.06.2021, 09:04}


Резултатния низ трябва да започва с ‘[‘,  да завършва с ‘]’ и да са изредени неговите стойности, разделени със запетаи.


Пример:

`[{stringId : “Hello world”}, {First uni day : 15.10.2021}, {Work day start, 10:15},  {OOP Exam: 23.06.2021, 09:04} ] `

Реализирайте главна функция, или еквивалентни `unit tests`, която създава `FJSON` обект и множество стойности в него и тества реализираните функционалности.

# Задача 2
1. Да се дефинира клас `Word`, описващ дума, съставена от не повече от 20 символа от тип char. Класът да съдържа следните операции:

    - операция[] за получаване на i-тия пореден символ в думата

    - операции + и += за добавяне на един символ в края на думата. Ако думата вече има 20 символа, операциите да нямат ефект

    - операции < и == за сравнение на думи спрямо лексикографската наредба

    - подходящи конструктори

 

2. Де се дефинира клас `Sentence`, описващ символен низ, състоящ се от произволен брой символи от тип char. Низът да се запазва в динамичната памет. Класът да поддържа следните операции

    - функция addWord за добавяне на дума (обект от клас Word) към края на изречението

    - класът да притежава всички необходими методи за осигуряване на правилен жизнен цикъл на обектите

    - метод за извеждане в изходен поток 

 

3. Да се дефинира клас `EnglishSentence`, наследник на клас `Sentence`, който допуска изречения, съставени единствено от малки и големи латински букви и символите интервал, запетая, удивителен знак и точка.

    - Упътване: за целта да се дефинира подходящ вариант на метода `addWord`.

 

4. Да се дефинира функция 

    - void addAndPrint ([подходящ тип] sentences, [подходящ тип] words[,...]),

 

където `sentences` е масив от произволен брой разнородни изречения, всяко от които може да е както обект от клас `Sentence`, така и обект от клас `EnglishSentence`, a words е масив от произволен брой думи. Ако е необходимо, функцията да има и допълнителни параметри. Функцията опитва да добави всяка от думите от words към всяко от изреченията в sentences чрез извикване на метода addWord и след това извежда всички така получени изречения.

# Задача 3
Класовете трябва да предоставят възможност за създаване на обекти. Да се създаде йерархия, която позволява работа със специален нов тип ресторанти (`AIRestaurants`).
Новите ресторанти се отличават с факта, че работят със сервитьори роботи. Когато се отвори(създаде) нов ресторант, за него се създават множество от роботи сервитьори. Тези сервитьори работят с точно определено меню, което ресторантът подава на всеки сервитьор при създаването му и което те могат да презентират пред клиента. Обърнете внимание, че менюто трябва да може да бъде различно за различните роботи, т.е. не се очаква да е едно за ресторанта.
Всеки ресторант има име, което е от тип `char *`, брой на масите (константна стойност), които могат да се обслужват, списък на сервитьори роботи. Броят на сервитьорите роботи съвпада с броя на масите.
Ресторантът има възможността да се копира, като неговото копие има същите методи, име, брой на масите и брой на сервитьори. Сервитьорите имат същите имена, презентират същите менюта, но са РАЗЛИЧНИ роботи.

Менюто има множество от константи стойности - имената на съответните ястия и техните цени и възможност за принтиране.

Всеки сервитьор робот има:
- идентификационен номер - инкрементираща уникална стойност 
- име от тип `char*`
- метод, който позволява да се представя пред клиента с думите `Welcome in our restaurant. My name is ...` и неговото име
- метод, който му позволява да покаже менюто на ресторанта. 
- метод за поръчване на определено ястие от менюто. Поръчката става с подаване на името на съответното ястие. Ако ястието не е част от менюто, методът хвърля грешка. Всяко поръчано ястие се записва в списък за поръчките за тази маса. 
- метод за поискване и плащане на сметка, който извежда всички поръчани ястия за съответната маса, тяхната цена и изчиства историята за направените поръчки като освобождава масата.

Ресторантът има специален метод за повикване на сервитьор ping, който по подадена маса извиква(връща) сервитьора за съответната маса. Приема се, че извикванията се правят от правилните клиенти и НЕ е необходима валидация за заета маса и други.
Да се напишат тестове или паралени извиквания на цялата функционалност в задачата.
