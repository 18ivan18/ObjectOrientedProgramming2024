## Design Patterns

### Какво представлява шаблонът за проектиране?

Шаблоните за проектиране са типични решения на често срещани проблеми при проектирането на софтуер. Те са като готови чертежи, които можем да персонализираме, за да решим повтарящ се проблем.

Не можем просто да намерим шаблон и да го копираме в програмата си, както можем да направите с готови функции или библиотеки. Шаблонът не е конкретна част от кода, а обща концепция за решаване на конкретен проблем. Можем да следваме детайлите на образеца и да реализираме решение, което отговаря на изискванията на нашата програма.

Шаблоните често се бъркат с алгоритмите, тъй като и двете понятия описват типични решения на някои известни проблеми. Докато един алгоритъм винаги дефинира ясен набор от действия, с които може да се постигне някаква цел, шаблонът е описание на решение на по-високо ниво. Кодът на един и същ шаблон, приложен към две различни програми, може да бъде различен.

Аналогия на алгоритъм е готварска рецепта: и двете съдържат ясни стъпки за постигане на дадена цел. От друга страна, шаблонът е по-скоро като проект: можете да видите какъв е резултатът и неговите характеристики, но точният ред на изпълнение зависи от вас.

### От какво се състои шаблонът?

Повечето шаблони са описани много формално, така че хората да могат да ги възпроизвеждат в много контексти.

### Класификация на шаблоните

Шаблоните за проектиране се различават по своята сложност, ниво на детайлност и степен на приложимост към цялата проектирана система. Можем да направим аналогия с пътното строителство: можете да направите едно кръстовище по-безопасно, като инсталирате няколко светофара или построите цял пътен възел на няколко нива с подземни проходи за пешеходци.

Най-основните модели от ниско ниво често се наричат идиоми. Те обикновено се прилагат само за един език за програмиране.

Най-универсалните модели от високо ниво са архитектурните модели. Разработчиците могат да приложат тези шаблони на практика на всеки език. За разлика от други шаблони, те могат да се използват за проектиране на архитектурата на цяло приложение.

Освен това всички шаблони могат да бъдат категоризирани според техния замисъл или цел.

Различаваме три основни групи шаблони:

- Шаблоните за създаване (**Creational patterns**) предоставят механизми за създаване на обекти, които увеличават гъвкавостта и повторното използване на съществуващия код.

- Структурните шаблони (**Structural patterns**) обясняват как да се сглобяват обекти и класове в по-големи структури, като тези структури се запазват гъвкави и ефективни.

- Поведенческите шаблони (**Behavioral patterns**) се грижат за ефективната комуникация и разпределянето на отговорностите между обектите.

## Singleton Pattern

Шаблонът Singleton решава два проблема едновременно, като нарушава принципа на една отговорност (**Single resonsibility principle**):

Гарантира се, че даден клас има само една инстанция. Защо някой би искал да контролира колко инстанции има един клас? Най-често срещаната причина за това е да се контролира достъпът до някакъв споделен ресурс - например база данни или файл.

Ето как става това: представяме си, че сме създали обект, но след известно време решаваме да създадем нов. Вместо да получим нов обект, ще получите този, който вече сме създали.

Това поведение е невъзможно да се реализира с обикновен конструктор, тъй като по замисъл извикването на конструктор трябва винаги да връща нов обект.

Глобалният достъп до обект

Клиентите може дори да не осъзнават, че работят с един и същ обект през цялото време.

Осигуряваме глобална точка за достъп до тази инстанция.
Подобно на една глобална променлива, шаблонът Singleton ни позволява да получим достъп до някакъв обект от всяка точка на програмата. Той обаче също така защитава тази инстанция от презаписване от друг код.

Този проблем има и друга страна: не искаме кодът, който решава проблем №1, да бъде разпръснат из цялата програма. Много по-добре е той да е в рамките на един клас, особено ако останалата част от кода ви вече зависи от него.
Singleton е станал толкова популярен, че хората могат да нарекат нещо singleton, дори ако то решава само един от изброените проблеми.

### Решение

Всички реализации на Singleton имат тези две общи стъпки:

Правим конструктора по подразбиране private, за да предотвратим използването на оператора new от други обекти в класа Singleton.
Декларираме статичен метод за създаване, който действа като конструктор. Този метод извиква private конструктора, за да създаде обект, и го записва в статично поле. Всички следващи извиквания на този метод връщат кеширания обект.
Ако кодът има достъп до класа Singleton, тогава той е в състояние да извика статичния метод на Singleton. Така че всеки път, когато се извика този метод, винаги се връща същият обект

## Задача 1. Unique Pointers

Напишете генеричен клас wrapper на така наречения raw pointer (указател в c++), който предоставя следните функционалности:

- Конструктор, приемащ указател от типа T
- Копиращ конструктор и оператор = са забранени
- Move семантиките са позволени (контруктор и оператор =)
- Предефиниране на оператор ->
- предефиниране на оператор \*
- методи get и reset

Целта на класа е да държи и управлява собствени указатели, без да се споделя отговорността и собствеността за тази памет.

## Задача 2. Shared Pointers

## Задача 3. Singleton

Имплементирайте клас Logger със следната функционалност:

- Singleton.
- Нека се отваря файл за писане с име log.txt
- Преди всеки лог искаме да се принтира времето на лога.
